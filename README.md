## 1. Модуль #1

### 1.1 Что такое Dependency Injection ?

**DI** - техника создания ПО, когда объекты не создают свои зависимости внутри себя. Вместо этого они объявляют зависимости, в которых нуждаются, и внешний объект / фрейморк предоставляет им эти зависимости

Примеры: 

* (без DI) внутри объекта переменная типа класса и создание экземпляра через `new()`.
* (ручной DI) переменная имеет тип интерфейса. Присваивание - через конструктор. Зависимость внедряется извне при создании объекта

Типы: 

* внедрение через конструктор
* внедрение через сеттер
* внедрение через интерфейс (клиент реализует интерфейс, который определяет как будет внедрятся зависимость (например через метод-сеттер)) [wiki](https://en.wikipedia.org/wiki/Dependency_injection#Interface_injection)

Преимущества:

* повышение переиспользования кода
* повышение читаемости
* улучшение сопровождения
* облегчение тестирования
* сокрашение связанности


### 1.2 Паттерн, антипаттерн, DI - паттерн?

Паттерн - переиспользуемое решение часто встречающихся проблем. Общее описание как решать эти проблемы.

Примеры: билдер, фабрика, стратегия, шаблонный метод

DI - паттерн, решаюший проблему гибкого создания зависимостей

### 1.3 Интерфейсы, преимущество их использования. Почему интерфейсы рекомендуются для Spring бинов

(ООП) Интерфейc - описание действий, которые может выполнять объект. Способ заставить объект, реализующий интерфейс выполнять действия

(Java) Интерфейс - ссылочный тип, содержащий коллекцию абстрактных методов. Класс, реализующий интерфейс, обязан реализовать эти методы или объявить их абстрактными

Преимущества:

* разделяют контракт и его реализацию
* позволяют определить контракт между объектами
* увеличивают взаимозаменяемость объектов
* упрощают тестирование

Преимущества интерфейсов для Spring:

* позволяют использовать JDK Dynamic Proxy
* скрывают реализации
    - интерфейс публичный, реализации - в пределах пакета
    - так вынуждаем использовать контракты, а не реализации
* позволяют легко менять бины (квалификаторы и др.)


### 1.4 Что такое Application Context?

Это центральная часть Spring приложения. Это интерфейс. Наследует несколько других интерфейсов

Отвечает за:

* инициализацию и конфигурацию бинов
* управление жизненным циклом бинов
* загрузку ресурсов (интерфейс `ResourceLoader`)
* отправку событий зарегистрированным обработчикам событий
* это фабрика бинов (интерфейс `BeanFactory`)
* доступ к `Environment` для получения свойств

Реализации **ApplicationContext**:

* AnnotationConfigApplicationContext - конфигурация на аннотациях
* AnnotationConfigWebApplicationContext - то же, но веб-приложения, для контейнера сервлетов
* ClassPathXmlApplicationContext - xml-конфигурация, файлы конфигурации в classpath
* FileSystemXmlApplicationContext - то же, но файлы конфигурации в файловой системе


### 1.5 Концепция контейнера и его жизненный цикл

#### 1.5.1 Введение 

Контайнер - окружение, предоставляющее разничные сервисы для использования. Обычно используется IoC

Spring предоставляет контейнер для управления бинами. Этот контейнер управляет жизненным циклом бинов и предоставляет дополнительные сервисы через **ApplicationContext**

Жизненный цикл контейнера Spring:

1. запускается приложение
2. создается контейнер
3. контейнер считывает конфигурацию
4. создаются определения (definitions) бинов на основании конфигурации 
5. определения бинов обрабатываются через **BeanFactoryPostProcessor**
    - это интерфейс, можно реализовывать для кастомной обработки
    - работает только с определениями бинов, никогда с экземплярами
6. создаются экземпляры бинов
7. бины настраиваются: свойства определяются, внедряются зависимости
8. вызываются реализации **BeanPostProcessor**
    - тоже интерфейс, для кастомной обработки
    - но работает уже с экземплярами бинов
9. приложение запущено
10. приложение завершает работу
11. закрывается Spring Context
12. вызываются обработчики завершения жизненного цикла бинов


BeanFactoryPostProcessor vs BeanPostProcessor:

* BFPP вызывается после того как прочитаны все определения бинов, до создания экземпляров
* BPP вызывается после создания экземпляра (в начале работы контейнера или в процессе работы приложения, если загрузка по требованию)

#### 1.5.2 Кратко о жизненном цикле


##### 1.5.2.1 Аннотации @PostConstruct и @PreDestroy

Подключить зависимость javax.annotation/javax.annotation-api

Аннотации можно ставить на методах бина, будут вызваны контейнером

##### 1.5.2.2 Переопределение BeanFactoryPostProcessor

Создаем класс, реализующий **BeanFactoryPostProcessor**

Включаем в состав контейнера (любым способом, например через `@Component`)

Переопределяем метод `postProcessBeanFactory()`

Внутри есть доступ к определениям бинов

Вызывается после чтения конфигурации и создания описания бинов, до фактического создания экземпляров бинов

##### 1.5.2.3 Переопределение BeanPostProcessor

Создаем класс, реализующий **BeanPostProcessor**

Включаем в состав контейнера (любым способом, например через `@Component`)
 
Два метода можно переопределить: `postProcessBeforeInitialization()` и `postProcessAfterInitialization()`. Внутри есть доступ к имени бина и экземпляру бина

##### 1.5.2.4 Порядок вызова

* сначала конструктор бина
* затем метод BeanPostProcessor `postProcessBeforeInitialization()`
* метод бина с `@PostConstruct`
* метод BeanPostProcessor `postProcessAfterInitialization()`


### 1.6 Как создать экземпляр ApplicationContext

#### 1.6.1 Не веб приложение

##### 1.6.1.1 Через аннотации (AnnotationConfigApplicationContext)

можно создать экземпляр **AnnotationConfigApplicationContext**

У этого класса есть методы из разных интерфейсов для чтения/создания конфигурации бинов:

* **scan(String ...basePackage)** - ищет определения бинов в указаном пакете
* **register(Class < ? > ...componentClasses)** - определения на основе компонентных классов 
 - с аннотацией `@ComponentScan`, где указывается пакет для сканирования (или без указания явного, по пакету класса)
 - с аннотацией `@Configuration`, в этом классе содержатся бины
* **refresh()** - обновляет конфигурацию. 

Соответственно разные конструкторы:

* пустой
    - для дальнейшего вызова `scan()` с указанием пакета 
    - или вызова `register()` с указанием конфигурационного класса
    - и вызова `refresh()`
* с указанием конфигурационного класса
    - внутри вызывается `register()` и `refresh()`
* с указанием пакета с бинами
    - внутри вызывается `scan()` и `refresh()`

**Итого способы**:

* через указание пакетов для сканирования строкой
* через класс, указывающий на пакет (**@ComponentScan**)
* через класс, содержащий бины (**@Configuration**)


##### 1.6.1.2 Через xml конфигурацию в classpath (ClassPathXmlApplicationContext)

Задаем конфигурацию в xml в `/src/main/resources`

получаем контекст 
    
    ApplicationContext contextFromClasspathXml = new 
        new ClassPathXmlApplicationContext("configs.xml");

##### 1.6.1.3 Через xml конфигурацию в файле (FileSystemXmlApplicationContext)

Получаем ресурс
    
    String beansXmlLocationOnFilesystem = App.class.getResource("/beanConfig.xml").toExternalForm();

Получаем конфигурацию

    ApplicationContext contextFromFileXml = new FileSystemXmlApplicationContext(beansXmlLocationOnFilesystem);


#### 1.6.2 Веб приложение

##### 1.6.2.1 Через Servlet 2 API

* Создаем `src/java/webapp/WEB_INF/web.xml`
    - listener указываем 
    - servlet настраиваем (через спринговский **DispatcherServlet**)
        + указываем файл конфигурации бинов `WEB-INF/beans.xml`
    - настраиваем маппинги для контроллеров
* настраиваем файл `WEB-INF/beans.xml`
    - контроллеры описываем
    - другие бины (сервисы и пр.)
* запускается в контейнере сервлетов (tomcat и т. п.)

##### 1.6.2.2 Через Servlet 3 API через xml конфигурацию

* Создаем класс, реализующий **WebApplicationInitializer**
    - загружает контекст из кофигурационного файла `WEB-INF/beans.xml` через **XmlWebApplicationContext**
    - регистрируем **DispatcherServlet**
    - задаем маппинги
* есть файл `WEB-INF/web.xml`, но пустой и формат отличен от версии для API v. 2
* бины, контроллер описываются в файле `WEB-INF/beans.xml`

##### 1.6.2.3 Через Servlet 3 API через аннотации

* Создаем класс, реализующий **WebApplicationInitializer**
    - загружает контекст через **AnnotationConfigWebApplicationContext** (аналог AnnotationConfigApplicationContext, см. 1.1.1)
    - регистрируем **DispatcherServlet**
    - задаем маппинги
* есть файл `WEB-INF/web.xml`, но пустой и формат отличен от версии для API v. 2
* бины конфигурируются одним из способов п. 1.1.1





#### 1.6.3 Spring Boot

На себя берет дополнительную работу

Сканирует автоматически в корневом пакете

Просто подключай зависимости (стартеры)

Для CLI создавай бин, реализующий CommandLineRunner (можно на самом **@SpringBootApplication**)


### 1.7 Методы жизненного цикла бина в ApplicationContext

* создается контекст
    - определения бинов создаются на основе конфигурации
    - вызывается метод интерфейса **BeanFactoryPostProcessor**
* создаются бины 
    - создаются экземпляры бинов
    - устанавливаются зависимости и свойства
    - вызывается **BeanPostProcessor::postProcessBeforeInitialization()**
    - вызывается метод с аннотацией **@PostConstruct**
    - вызывается метод **InitializingBean::afterPropertiesSet()**
        + бин должен реализовывать этот интерфейс
        + для проверки/установки свойств
    - вызывается метод из аннотации **@Bean(initMethod=...)**
    - вызывается **BeanPostProcessor::postProcessAfterInitialization()**
* бин готов к использованию
* контекст уничтожается, и вместе с ним уничтожаются бины
    - вызывается метод с аннотацией **@PreDestroy**
    - вызывается метод **DisposableBean::destroy()**
        + бин должен реализовывать этот интерфейс
    - вызывается метод из аннотации **@Bean(destroyMethod=...)**

Еще более подробно, см. [BeanFactory docs](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html)

### 1.8 Как создавать ApplicationContext в интеграционных тестах

Подключаем зависимость

    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <scope>test</scope>
    </dependency>

Тест создаем с аннотациями

    @RunWith(SpringRunner.class)
    @ContextConfiguration(classes = ApplicationConfiguration.class)
    public class EmployeesSalariesReportServiceTest {
        // логика теста
    }

Здесь `@RunWith` - из JUnit (возможно только 4)
`SpringRunner` - класс из `spring-test`, создается контекст таким образом
`@ContextConfiguration` - аннотация, определяющаяконфигурационный класс для контекста

### 1.9 Способы закрыть контекст

Если не закрыть правильно, не будут вызваны методы жизненного цикла на уничтожение бинов (@`PreDestroy` и т. п.)

* не веб-приложение:
    - (рекомендуется) установить хук **ConfigurableApplicationContext::registerShutdownHook**
    - вызвать **ConfigurableApplicationContext::close**
* веб-приложение:
    - **ContextLoaderListener** автоматически закроет контекст, когда веб-контейнер остановит приложение
* SpringBoot:
    - **ApplicationContext** будет автоматически остановлен
    - Shutdown хук регистрируется автоматически
    - **ContextLoaderListener** также автоматически закрывает контекст в веб-приложении 

**Кратко**:

* веб, SpringBoot - закроют автоматом
* в остальных - `ctx.registerShutdownHook();`


### 1.10 DI с помощью java конфигурации, DI с помощью аннотаций. Сканирование компонентов, стереотипные аннотации, мета-аннотации

#### 1.10.1 DI с помощью java конфигурации

Все бины объявляются в классе-конфигурации (с аннотацией **@Configuration**) c помощью аннотации **@Bean** над методами. Для внедрения зависимостей используется **@Autowired**

    @Configuration
    public class ApplicationConfiguration {
        @Bean
        Bean1 bean1(){
            return new Bean1();
        }

Собственно классы бинов не имеют никаких аннотаций

На основании конфигурации создается контекст

    ApplicationContext ctx = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);

#### 1.10.2 DI с помощью аннотаций

Создаем классы-бины с аннотацией **@Component**. Внутри можно внедрять зависимости через **@Autowired**.

    @Component
    public class SpringBean1 {...}

Создаем конфигурацию, разрешающую сканирование

    @ComponentScan
    public class ApplicationConfiguration {...}

Также создаем контекст
    
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);


#### 1.10.3 Варианты сканирования компонентов

Можно просто указать аннотацию **@ComponentScan** без уточнений, тогда целью сканирования будет пакет, где расположен класс-конфигурация и вложенные пакеты

    @ComponentScan
    public class ApplicationConfiguration {...}

Можно указать конкретный пакет для сканирования

    @ComponentScan(basePackage="a.b.x")
    public class ApplicationConfiguration {...}

или класс, по пакету которого будет проходить сканирование

    @ComponentScan(basePackageClasses = SomeBean.class)
    public class ApplicationConfiguration {...}

Можно еще дополнительно фильтры

    @ComponentScan(
       basePackages = "a.b.c",
       includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean.*"),
       excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean1.*")

#### 1.10.4 Стереотипные аннотации

Аннотации, применяемые к классу, для описания его роли. Spring создает бины для классов, помеченных такими аннотациями. 

Сравнение с **@Bean**: Bean - аннотация для метода, стереотипные аннотации - для типов (классов)

Примеры:

* **@Component** - компонент общего назначения
* **@Service** - класс, содержащий бизнес-логику
* **@Repository** - класс, использующийся для доступа к БД
* **@Controller** - класс контроллер, обычно в веб-приложении

С точки зрения контейнера все эти виды равнозначны, и только разработчик определяет их смысл

#### 1.10.5 Мета-аннотации

Аннотации, состоящие из других аннотаций

Пример - **@RestController** = **@Controller** + **@ResponseBody**




#### 1.10.6 Область видимости бинов (scope)

* Singleton - один бин на контейнер. По умолчанию
* Prototype - каждый раз, когда требуется бин - создается новый экземпляр
* Request - новый экземпляр на каждый запрос
* Session - новый экземпляр на сессию
* Application - один экземпляр на ServletContext
* WebSocket - один экземпляр на каждый сокет
