## 1. Модуль #1. Основы / Spring Core

### 1.1 Что такое Dependency Injection ?

**DI** - техника создания ПО, когда объекты не создают свои зависимости внутри себя. Вместо этого они объявляют зависимости, в которых нуждаются, и внешний объект / фрейморк предоставляет им эти зависимости

Примеры: 

* (без DI) внутри объекта переменная типа класса и создание экземпляра через `new()`.
* (ручной DI) переменная имеет тип интерфейса. Присваивание - через конструктор. Зависимость внедряется извне при создании объекта

Типы: 

* внедрение через конструктор
* внедрение через сеттер
* внедрение через интерфейс (клиент реализует интерфейс, который определяет как будет внедрятся зависимость (например через метод-сеттер)) [wiki](https://en.wikipedia.org/wiki/Dependency_injection#Interface_injection)

Преимущества:

* повышение переиспользования кода
* повышение читаемости
* улучшение сопровождения
* облегчение тестирования
* сокрашение связанности


### 1.2 Паттерн, антипаттерн, DI - паттерн?

Паттерн - переиспользуемое решение часто встречающихся проблем. Общее описание как решать эти проблемы.

Примеры: билдер, фабрика, стратегия, шаблонный метод

DI - паттерн, решаюший проблему гибкого создания зависимостей

### 1.3 Интерфейсы, преимущество их использования. Почему интерфейсы рекомендуются для Spring бинов

(ООП) Интерфейc - описание действий, которые может выполнять объект. Способ заставить объект, реализующий интерфейс выполнять действия

(Java) Интерфейс - ссылочный тип, содержащий коллекцию абстрактных методов. Класс, реализующий интерфейс, обязан реализовать эти методы или объявить их абстрактными

Преимущества:

* разделяют контракт и его реализацию
* позволяют определить контракт между объектами
* увеличивают взаимозаменяемость объектов
* упрощают тестирование

Преимущества интерфейсов для Spring:

* позволяют использовать JDK Dynamic Proxy
* скрывают реализации
    - интерфейс публичный, реализации - в пределах пакета
    - так вынуждаем использовать контракты, а не реализации
* позволяют легко менять бины (квалификаторы и др.)


### 1.4 Что такое Application Context?

Это центральная часть Spring приложения. Это интерфейс. Наследует несколько других интерфейсов

Отвечает за:

* инициализацию и конфигурацию бинов
* управление жизненным циклом бинов
* загрузку ресурсов (интерфейс `ResourceLoader`)
* отправку событий зарегистрированным обработчикам событий
* это фабрика бинов (интерфейс `BeanFactory`)
* доступ к `Environment` для получения свойств

Реализации **ApplicationContext**:

* AnnotationConfigApplicationContext - конфигурация на аннотациях
* AnnotationConfigWebApplicationContext - то же, но веб-приложения, для контейнера сервлетов
* ClassPathXmlApplicationContext - xml-конфигурация, файлы конфигурации в classpath
* FileSystemXmlApplicationContext - то же, но файлы конфигурации в файловой системе


### 1.5 Концепция контейнера и его жизненный цикл

#### 1.5.1 Введение 

Контайнер - окружение, предоставляющее разничные сервисы для использования. Обычно используется IoC

Spring предоставляет контейнер для управления бинами. Этот контейнер управляет жизненным циклом бинов и предоставляет дополнительные сервисы через **ApplicationContext**

Жизненный цикл контейнера Spring:

1. запускается приложение
2. создается контейнер
3. контейнер считывает конфигурацию
4. создаются определения (definitions) бинов на основании конфигурации 
5. определения бинов обрабатываются через **BeanFactoryPostProcessor**
    - это интерфейс, можно реализовывать для кастомной обработки
    - работает только с определениями бинов, никогда с экземплярами
6. создаются экземпляры бинов
7. бины настраиваются: свойства определяются, внедряются зависимости
8. вызываются реализации **BeanPostProcessor**
    - тоже интерфейс, для кастомной обработки
    - но работает уже с экземплярами бинов
9. приложение запущено
10. приложение завершает работу
11. закрывается Spring Context
12. вызываются обработчики завершения жизненного цикла бинов


BeanFactoryPostProcessor vs BeanPostProcessor:

* BFPP вызывается после того как прочитаны все определения бинов, до создания экземпляров
* BPP вызывается после создания экземпляра (в начале работы контейнера или в процессе работы приложения, если загрузка по требованию)

#### 1.5.2 Кратко о жизненном цикле


##### 1.5.2.1 Аннотации @PostConstruct и @PreDestroy

Подключить зависимость javax.annotation/javax.annotation-api

Аннотации можно ставить на методах бина, будут вызваны контейнером

##### 1.5.2.2 Переопределение BeanFactoryPostProcessor

Создаем класс, реализующий **BeanFactoryPostProcessor**

Включаем в состав контейнера (любым способом, например через `@Component`)

Переопределяем метод `postProcessBeanFactory()`

Внутри есть доступ к определениям бинов

Вызывается после чтения конфигурации и создания описания бинов, до фактического создания экземпляров бинов

##### 1.5.2.3 Переопределение BeanPostProcessor

Создаем класс, реализующий **BeanPostProcessor**

Включаем в состав контейнера (любым способом, например через `@Component`)
 
Два метода можно переопределить: `postProcessBeforeInitialization()` и `postProcessAfterInitialization()`. Внутри есть доступ к имени бина и экземпляру бина

##### 1.5.2.4 Порядок вызова

* сначала конструктор бина
* затем метод BeanPostProcessor `postProcessBeforeInitialization()`
* метод бина с `@PostConstruct`
* метод BeanPostProcessor `postProcessAfterInitialization()`


### 1.6 Как создать экземпляр ApplicationContext

#### 1.6.1 Не веб приложение

##### 1.6.1.1 Через аннотации (AnnotationConfigApplicationContext)

можно создать экземпляр **AnnotationConfigApplicationContext**

У этого класса есть методы из разных интерфейсов для чтения/создания конфигурации бинов:

* **scan(String ...basePackage)** - ищет определения бинов в указаном пакете
* **register(Class < ? > ...componentClasses)** - определения на основе компонентных классов 
 - с аннотацией `@ComponentScan`, где указывается пакет для сканирования (или без указания явного, по пакету класса)
 - с аннотацией `@Configuration`, в этом классе содержатся бины
* **refresh()** - обновляет конфигурацию. 

Соответственно разные конструкторы:

* пустой
    - для дальнейшего вызова `scan()` с указанием пакета 
    - или вызова `register()` с указанием конфигурационного класса
    - и вызова `refresh()`
* с указанием конфигурационного класса
    - внутри вызывается `register()` и `refresh()`
* с указанием пакета с бинами
    - внутри вызывается `scan()` и `refresh()`

**Итого способы**:

* через указание пакетов для сканирования строкой
* через класс, указывающий на пакет (**@ComponentScan**)
* через класс, содержащий бины (**@Configuration**)


##### 1.6.1.2 Через xml конфигурацию в classpath (ClassPathXmlApplicationContext)

Задаем конфигурацию в xml в `/src/main/resources`

получаем контекст 
    
    ApplicationContext contextFromClasspathXml = new 
        new ClassPathXmlApplicationContext("configs.xml");

##### 1.6.1.3 Через xml конфигурацию в файле (FileSystemXmlApplicationContext)

Получаем ресурс
    
    String beansXmlLocationOnFilesystem = App.class.getResource("/beanConfig.xml").toExternalForm();

Получаем конфигурацию

    ApplicationContext contextFromFileXml = new FileSystemXmlApplicationContext(beansXmlLocationOnFilesystem);


#### 1.6.2 Веб приложение

##### 1.6.2.1 Через Servlet 2 API

* Создаем `src/java/webapp/WEB_INF/web.xml`
    - listener указываем 
    - servlet настраиваем (через спринговский **DispatcherServlet**)
        + указываем файл конфигурации бинов `WEB-INF/beans.xml`
    - настраиваем маппинги для контроллеров
* настраиваем файл `WEB-INF/beans.xml`
    - контроллеры описываем
    - другие бины (сервисы и пр.)
* запускается в контейнере сервлетов (tomcat и т. п.)

##### 1.6.2.2 Через Servlet 3 API через xml конфигурацию

* Создаем класс, реализующий **WebApplicationInitializer**
    - загружает контекст из кофигурационного файла `WEB-INF/beans.xml` через **XmlWebApplicationContext**
    - регистрируем **DispatcherServlet**
    - задаем маппинги
* есть файл `WEB-INF/web.xml`, но пустой и формат отличен от версии для API v. 2
* бины, контроллер описываются в файле `WEB-INF/beans.xml`

##### 1.6.2.3 Через Servlet 3 API через аннотации

* Создаем класс, реализующий **WebApplicationInitializer**
    - загружает контекст через **AnnotationConfigWebApplicationContext** (аналог AnnotationConfigApplicationContext, см. 1.1.1)
    - регистрируем **DispatcherServlet**
    - задаем маппинги
* есть файл `WEB-INF/web.xml`, но пустой и формат отличен от версии для API v. 2
* бины конфигурируются одним из способов п. 1.1.1





#### 1.6.3 Spring Boot

На себя берет дополнительную работу

Сканирует автоматически в корневом пакете

Просто подключай зависимости (стартеры)

Для CLI создавай бин, реализующий CommandLineRunner (можно на самом **@SpringBootApplication**)


### 1.7 Методы жизненного цикла бина в ApplicationContext

* создается контекст
    - определения бинов создаются на основе конфигурации
    - вызывается метод интерфейса **BeanFactoryPostProcessor**
* создаются бины 
    - создаются экземпляры бинов
    - устанавливаются зависимости и свойства
    - вызывается **BeanPostProcessor::postProcessBeforeInitialization()**
    - вызывается метод с аннотацией **@PostConstruct**
    - вызывается метод **InitializingBean::afterPropertiesSet()**
        + бин должен реализовывать этот интерфейс
        + для проверки/установки свойств
    - вызывается метод из аннотации **@Bean(initMethod=...)**
    - вызывается **BeanPostProcessor::postProcessAfterInitialization()**
* бин готов к использованию
* контекст уничтожается, и вместе с ним уничтожаются бины
    - вызывается метод с аннотацией **@PreDestroy**
    - вызывается метод **DisposableBean::destroy()**
        + бин должен реализовывать этот интерфейс
    - вызывается метод из аннотации **@Bean(destroyMethod=...)**

Еще более подробно, см. [BeanFactory docs](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html)

### 1.8 Как создавать ApplicationContext в интеграционных тестах

Подключаем зависимость

    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <scope>test</scope>
    </dependency>

Тест создаем с аннотациями

    @RunWith(SpringRunner.class)
    @ContextConfiguration(classes = ApplicationConfiguration.class)
    public class EmployeesSalariesReportServiceTest {
        // логика теста
    }

Здесь `@RunWith` - из JUnit (возможно только 4)
`SpringRunner` - класс из `spring-test`, создается контекст таким образом
`@ContextConfiguration` - аннотация, определяющаяконфигурационный класс для контекста

### 1.9 Способы закрыть контекст

Если не закрыть правильно, не будут вызваны методы жизненного цикла на уничтожение бинов (@`PreDestroy` и т. п.)

* не веб-приложение:
    - (рекомендуется) установить хук **ConfigurableApplicationContext::registerShutdownHook**
    - вызвать **ConfigurableApplicationContext::close**
* веб-приложение:
    - **ContextLoaderListener** автоматически закроет контекст, когда веб-контейнер остановит приложение
* SpringBoot:
    - **ApplicationContext** будет автоматически остановлен
    - Shutdown хук регистрируется автоматически
    - **ContextLoaderListener** также автоматически закрывает контекст в веб-приложении 

**Кратко**:

* веб, SpringBoot - закроют автоматом
* в остальных - `ctx.registerShutdownHook();`


### 1.10 DI с помощью java конфигурации, DI с помощью аннотаций. Сканирование компонентов, стереотипные аннотации, мета-аннотации

#### 1.10.1 DI с помощью java конфигурации

Все бины объявляются в классе-конфигурации (с аннотацией **@Configuration**) c помощью аннотации **@Bean** над методами. Для внедрения зависимостей используется **@Autowired**

    @Configuration
    public class ApplicationConfiguration {
        @Bean
        Bean1 bean1(){
            return new Bean1();
        }

Собственно классы бинов не имеют никаких аннотаций

На основании конфигурации создается контекст

    ApplicationContext ctx = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);

#### 1.10.2 DI с помощью аннотаций

Создаем классы-бины с аннотацией **@Component**. Внутри можно внедрять зависимости через **@Autowired**.

    @Component
    public class SpringBean1 {...}

Создаем конфигурацию, разрешающую сканирование

    @ComponentScan
    public class ApplicationConfiguration {...}

Также создаем контекст
    
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);


#### 1.10.3 Варианты сканирования компонентов

Можно просто указать аннотацию **@ComponentScan** без уточнений, тогда целью сканирования будет пакет, где расположен класс-конфигурация и вложенные пакеты

    @ComponentScan
    public class ApplicationConfiguration {...}

Можно указать конкретный пакет для сканирования

    @ComponentScan(basePackage="a.b.x")
    public class ApplicationConfiguration {...}

или класс, по пакету которого будет проходить сканирование

    @ComponentScan(basePackageClasses = SomeBean.class)
    public class ApplicationConfiguration {...}

Можно еще дополнительно фильтры

    @ComponentScan(
       basePackages = "a.b.c",
       includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean.*"),
       excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean1.*")

#### 1.10.4 Стереотипные аннотации

Аннотации, применяемые к классу, для описания его роли. Spring создает бины для классов, помеченных такими аннотациями. 

Сравнение с **@Bean**: Bean - аннотация для метода, стереотипные аннотации - для типов (классов)

Примеры:

* **@Component** - компонент общего назначения
* **@Service** - класс, содержащий бизнес-логику
* **@Repository** - класс, использующийся для доступа к БД
* **@Controller** - класс контроллер, обычно в веб-приложении

С точки зрения контейнера все эти виды равнозначны, и только разработчик определяет их смысл

#### 1.10.5 Мета-аннотации

Аннотации, состоящие из других аннотаций

Пример - **@RestController** = **@Controller** + **@ResponseBody**

#### 1.10.6 Область видимости бинов (scope)

* Singleton - один бин на контейнер. По умолчанию
* Prototype - каждый раз, когда требуется бин - создается новый экземпляр
* Request - новый экземпляр на каждый запрос
* Session - новый экземпляр на сессию
* Application - один экземпляр на ServletContext
* WebSocket - один экземпляр на каждый сокет

Задается через аннотацию **@Scope**, которая ставиться рядом с **@Component** над классом или рядом с **@Bean** над методом.

**!! не путать:** нет смысла ставить над классом бина, если контекст создается через класс-конфигурацию (`@Configuration`). В этом случае ставить нужно над методом класса-конфигурации:

    //@Scope("prototype") - не имеет смысла
    public class Bean1 {...}

    @Configuration
    public class Config {
        @Bean
        @Scope("prototype") // здесь можно
        public Bean1 bean1() {return new Bean1();}
    }

### 1.11 Ленивая/горячая (lazy/eagerly) загрузка бинов

Зависит от области видимости:

* Singleton по умолчанию загружаются всегда (eagerly)
* Prototype - ленивая загрузка (по требованию)
    - исключение: если prototype-бин входит в состав синлтона, тогда он также загружается всегда

Изменение варианта загрузки:

* через **@ComponentScan(lazyInit=true/false)**
    - по умолчанию - false, Singleton - eagerly, Prototype - lazy
    - true - все бины - lazy, даже сингтоны
* через аннотацию **@Lazy(true/false)**
    - по умолчанию включает lazy режим
    - `@Lazy(false)` - eagerly
    - где можно применять:
        + на `@ Component`: этот бин будет загружаться, как указывает `@Lazy`
        + на `@Configuration`: все бины этой конфигурации загружаются, как указывает `@Lazy`
        + на метод с `@Bean`: этот бин загружается, как указывает `@Lazy`
         

### 1.12 Что такое property source / @PropertySource

Абстракция над парами ключ-значения Environment. Источники: 

* JVM свойства
* системные переменные окружения
* файлы свойств, расположенные в файловой системе
* файлы свойств, расположенные в classpath

**@PropertySource** и **@PropertySources** задают положение источников. Применяется совместно с **@Configuration** (или **@ComponentScan**)

Получаем через **@Value**

Подробнее [github](https://github.com/Worrovsky/spring-vue-learn-stuff/tree/main/003-spring-boot-properties)


### 1.13 BeanFactoryPostProcessor: когда вызывается, почему следует делать метод c @Bean, где он создается, статический. Что такое PropertySourcesPlaceholderConfigurer

**BeanFactoryPostProcessor** - интерфейс с единственным методом **postProcessBeanFactory**.

Позволяет менять определения бинов до их создания.

Вызывается после того, как контейнер прочитал определения бинов, но до создания экземпляров бинов

BFPP - это тоже бин, но должен быть создан ранее, чтобы обрабатывать другие бины.
Здесь [docs BFPP](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) сказано, что ApplicationContext распознает этот бин и применяет его перед созданием других бинов.

Здесь [docs @Bean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html) описано про применение статического метода для создания BFPP. Тогда BFPP будет создан раньше других бинов, и не будет проблем из-за позднего создания

    @Configuration
    public class AppConfig {
        @Bean public static BFPP bfpp() {...}
    } 

**PropertySourcesPlaceholderConfigurer** - реализация BFPP. Решает задачу замены placeholder'а `${...}` в свойствах бинов в аннотациях `@Value`

### 1.14 Что такое BeanPostProcessor. Инициализационный метод бина. Метод на уничтожение бина (destroy)

#### 1.14.1 BeanPostProcessor

BPP - интерфейс, чьи методы позволяют модифицировать создание экземпляров бинов.

Два метода:

* **postProcessBeforeInitialization()**
* **postProcessAfterInitialization()**

Главное отличие BFPP vs BPP: BFPP работает с определениями бинов, BPP - с экземплярами бинов

Места BFPP и BPP в жизненном цикле бина:

1. читается конфигурация, создаются определения бинов
2. вызывается метод BFPP
3. создаются экземпляры бинов
4. устанавливаются зависимости и свойства
5. вызывается **BeanPostProcessor::postProcessBeforeInitialization()**
6. вызывается метод с аннотацией **@PostConstruct**
7. вызывается метод **InitializingBean::afterPropertiesSet()**
8. вызывается метод из аннотации **@Bean(initMethod=...)**
9. вызывается **BeanPostProcessor::postProcessAfterInitialization()**

Рекомендуемый способ создания: статический @Bean метод в конфигурации

[пример для вопроса 7](/01-module-1/m1-q07-bean-lifecycle)

#### 1.14.2 Инициализационный метод бина

Это метод, который используется для настройки бина в зависимости от свойств и зависимостей

Варианты метода:

* метод в бине с **@PostConstruct**
* реализовать метод из интерфейса **InitializingBean::afterPropertiesSet()**
* создать бин в **@Configuration**-классе и указать метод **@Bean(initMethod="...")**

Почему нельзя просто в конструкторе решить: по завершению конструктора не все зависимости могут быть установлены (через сеттеры например еще нет)

[пример для вопроса 7](/01-module-1/m1-q07-bean-lifecycle)

#### 1.14.3 Destroy метод

Метод, используемый для очистки ресурсов, когда бин завершает свой цикл. Обычно это происходит при закрытии контекста

Варианты:

* метод в бине с **@PreDestroy**
* реализовать метод из интерфейса **DisposableBean::destroy()**
* * создать бин в **@Configuration**-классе и указать метод **@Bean(destroyMethod="...")**




### 1.15 Что такое component-scanning

Это процесс, при котором Spring сканирует classpath для поиска классов со стереотипными аннотациями (`@Component` и производными) и создает определения бинов

Подробнее про варианты задания области для сканирования см. п. 1.10.3

Пример: [github](01-module-1/m1-q06-application-context/01-non-web-app/src/main/java/config/BeanPackageScanConfig.java)

### 1.16 @Autowired и разные виды внедрений (через поле, конструктор, метод)

**@Autowired** - аннотация, которая обрабатывается **AutowiredAnnotationBeanPostProcessor**.

Может размещаться над:

* конструктором
* полем
* сеттером
* конфигурационным методом

Поиск бина в основном основан на типах.

По умолчанию зависимость обязательна. Необязательность можно указать несколькими способами: через тип `Optional`, аннотацией `@Nullable` или `@Autowired(required = false)`

Можно `@Autowired` указывать над типами `Collection` или `Map`. Тогда Spring будет помещать в коллекцию все бины этого типа или пару имя бина / бин в Map. Порядок определяется `@Order`, `@Priority` или реализацией `Ordered`

Порядок разрешения зависимости:

1. Проверяется соответствие по типу, если найден ровно один бин - поиск завершается.
2. Если найдено несколько бинов по типу, проверяется есть ли аннотация **@Primary**. Если есть такой бин - завершается
3. Проверяется, есть ли `@Qualifier` для поля, ищется по нему
4. Если всё еще не найден, ищется по имени бина
5. Если не найден - исключение (`NoSuchBeanDefinitonException`, `NoUniqueBeanDefinitionException`)

**Внедрение через поле**

    @Autowired
    public SomeType field;

Модификатор доступа - любой.

Внедрение происходит после создания экземпляра, но до вызова любого инициализационного метода.

По умолчанию - обязателен, но можно любым способом необязательность указать.

**Внедрение через конструктор**

    @Autowired
    public SomeClass(SomeType f) {
        this.field = f; 
    }

Конструктор может иметь любой модификатор доступа

Если есть единственный конструктор - можно не указывать `@Autowired`, Spring сам его будет использовать и внедрит зависимости.

Если несколько конструкторов - обязаны пометить один, если нет - исключение **NoSuchMethodExeption**

По умолчанию все параметры обязательны, но можно любым способом параметр необязательным указать. 

**Внедрение через метод**

    @Autowired
    public void setDep(SomeType f) {
        this.someField = f;
    }

Опять же модификатор доступа - любой.

Может быть несколько параметров. Если не сможет определить бин - исключения `NoSuchBeanDefinitonException`, `NoUniqueBeanDefinitionException`

Если указать `@Autowired(required = false`) над методом, метод будет вызван только если будут разрешены все параметры.

Можно также сделать необязательными часть параметров.



### 1.17 Внедрение в приватные поля и влияение на тестирование

2 способа ввести зависимость в приватное поле:

* `@Autowired`
* `@Value`

Доступа к приватным полям извне нет, для тестирования следующие способы:

* `@SpringRunner` + `@ContextConfiguration` + `@MockBean`
* `ReflectionTestUtils` для модификации приватного поля
    - завязан на имя поля, возможны проблемы при переименовании
* `@MockitoJUnitRunner`
* `@TestPropertySources` для задания значения свойств

TODO: рассмотреть примеры


### 1.18 Аннотация @Qualifier и ее применение вместе с @Autowired

**@Qualifier** дает дополнительный контроль в определении какой бин внедрять, когда по типу соответствует несколько. Решает проблему **NoUniqueBeanDefinitionException**

Если внедрение без **@Qualifier** основано на типах, внедрение c помощью **@Qualifier** основано на именах бинов.

Имена бинов:

* по умолчанию по имена класса
* или метода, если бин вводится через `@Bean`
* можно свое указать в аннотациях `@Component("...")` и производных

Разные варианты использования:

* Над местом внедрения с именем бина в качестве значения
    - используется имя бина
* Над местом внедрения и определением бина
    - задается псевдоним над определением бина и он же используется при внедрении
* Кастомные аннотации

**Подробнее про кастомную аннотацию:**

Создаем свою аннотацию, наследуемся от `@Qualifier`

Внутри создаем значение (можно enum создать для этого или просто строковое)

    @Qualifier
    @Target({ElementType.FIELD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ReportType {
        ReportTypeMode value();
        enum ReportTypeMode {
            TYPE_1,
            TYPE_2
        }
    }

Теперь эту аннотацию ставим в двух местах: над определением бина и в месте внедрения с одинаковыми значениями

### 1.19 Proxy-объекты

Proxy - это объект, добавляющий дополнительную логику для проксируемого объекта, без модификации этого объекта. Proxy имеет те же публичные методы, что и проксируемый объект и должен быть по возможности неотличим от него.

Обычно Proxy добавляет дополнительную функциональность (логгирование, Security и т. п.) до и после методов проксируемого объекта.

Spring применяет два типа:

* JDK Dynamic Proxy - на основе интерфейсов
    - можно только проксировать объекты, реализующие интерфейсы
    - только методы интерфейса проксируются
    - не поддерживается self-invocation (вызов метода проксируемого объекта внутри другого метода проксируемого объекта)
* CGLIB Proxy - на основе наследования
    - не поддерживаются финальные классы
    - не поддерживаются финальные методы
    - также не поддерживает self-invocation

Преимущества Proxy:

* возможность изменить поведение объекта без изменения исходного кода
* разделение концептуальной логики (логгирование, транзакционность и т. п.)

Недостатки Proxy:

* трудности при отладке
* недоступность проверяемых исключений, можно добавлять только непроверяемые (сигнатура метода задана уже)
* могут быть проблемы с производительностью, если методы до и после обращаются к сети, дискам и т. п.
* неожиданное нарушение работы оператора `==`(прокси и проксируемый объект - разные) 



### 1.20 Преимущества и недостатки Java Config

Способы задания конфигураций:

* **Java Config**: класс с `@Configuration` и бинами внутри через `@Bean`
* **Annotation Based Config** - `@ComponentScan` + `@Component`
* **Xml Config**

Преимущества Java Config vs XML Config:

* Проверка типов бинов и полей для внедрения на этапе компиляции
    - вся конфигурация - обычный код, компилятор может видеть ошибки
    - xml же - обычный файл, компилятор никак не проверит (только если IDE поможет)
* Рефакторинг работает из коробки
    - те же причины

Преимущества Java Config vs Annotation Based Config:

* Разделение концепций конфигурация и реализация бинов:
    - бины - обычные классы, никак не отмеченные
    - только в отдельном классе с `@Configuration` собирается конфигурация
* Tecnology agnostic - бины ничего не знают о наличии IoC/DI
* Бинами можно делать объекты сторонних библиотек, к чьему коду нет доступа
* Конфигурация более централизована:
    - расположена в одном месте, легко читать

Недостатки Java Config:

* Конфигурационные классы не могут быть финальными и их методы тоже
    - Spring проксирует, чтобы контролировать процесс создания бинов (не вызывать дважды для singleton, например)
* Централизация может мешать в больших проектах 


### 1.21 Аннотация @Bean

Аннотация **@Bean** используется в классе **@Configuration** для информирования Spring, что объект, возвращаемый методом с аннотацией **@Bean**, является бином.

Возможности:

* можно указать **initMethod**: будет вызван после вызова конструктора и внедрения зависимостей
    - `@Bean(initMethod = "...")`
* можно указать **destroyMethod**
    - `@Bean(destroyMethod = "...")` 
    - не забыть закрыть контекст
* можно указать имя для бина
* можно указать псевдонимы (все, что кроме первого имени)
    - `@Bean(name = {"name", "alias1", "alias2"})`
* можно указать, является бин кандидатом для внедрения
    - `@Bean(autowiredCandidate = false)`
    - по умолчанию - является


### 1.22 Id бина по умолчанию. Как переопределить?

По умолчанию бина присваивается имя/id по методу, над которым стоит `@Bean`

Можно переопределить, указав явно имя или псевдонимы

    @Bean(name = {"name", "alias"})

### 1.23 Почему нельзя добавить к финальному классу аннотацию @Configuration. Как класс с @Configuration поддерживает синглетон-бины. Почему метод с @Bean не может быть финальным

Для класса @Configuration Spring создает прокси через CGLIB. CGLIB работает через наследование, поэтому для финальных классов не может создавать прокси. Также не сможет создать проксированный метод для финальных методов.

Если все же конфигурационный класс будет финальным, будет вызвано исключение **BeanDefinitionParsingExeption**

Проксирование нужно, чтобы поддерживать механизм синглетон-бинов. Метод для создания бинов проксируется. Если это синглетон, сначала проверяется, не создан ли уже бин. Если создан - возвращается существующий экземпляр. 

То, что прокси создается, можно увидеть в стактрейсе - класс будет не исходный, а с добавлением `$$EnhancerBySpringCGLIB$$`

### 1.24 Конфигурация профилей и примеры их использования

* Указать для бинов, к каким профилям они относятся.
* Указать какие профили активны.

**Способы указания профиля**:

* Использовать **@Profile** на уровне **@Component**, тогда этот бин будет частью профиля
* Использовать **@Profile** на уровне **@Configuration**, тогда все бины этой конфигурации будут относиться к этому профилю
* Использовать **@Profile** на уровне метода с **@Bean**, тогда бин, возвращаемый этим методом, будет частью профиля
* Создать собственную аннотацию на основе **@Profile**, и размещать ее как в первых 3-х примерах
    - просто создаем свою аннотацию
    - над ней помещаем аннотацию `@Profile("someProfile")`

Если для бина не задан профиль, подразумевается, что он относится ко всем профилям

Можно исключать бин из профиля с помощью `!`


**Способы активации профиля**

* программно через интерфейс `ConfigurableEnvironment`
    - `ctx.getEnvironment().setActiveProfiles("sql");`
* через использование свойства **spring.profiles.active**  
    - например через агрумент CLI `java -jar ... -Dspring.profiles.active=dev` 
* при тестировании JUnit `@ActiveProfiles`
* SpringBoot: программно через **SpringApplicationBuilder**
    - вместо `SpringApplication.run(App.class);`
    - `new SpringApplicationBuilder(App.class).profiles("emailProfile").run(args);`
* SpringBoot: через свойство **spring.profiles.active** например в файле `application.properties`    

**Примеры использования**:

* изменение поведения в различном окружении: prod / dev / и т. п.
* изменение поведения для разных заказчиков
* изменение поведения для тестирования
* добавление в систему дополнительных возможностей: отладка, мониторинг


### 1.25 Можно ли использовать @Bean вместе с @Profile

Да, в случае Java Config (комбинация **@Configuration** + **@Bean** + **Profile**)

Подробнее см. п. 1.24

Разные варианты:

    @Profile("prod")
    @Profile("!prod")
    @Profile({"prod", "dev"})



### 1.26 Можно ли использовать @Component вместе с @Profile

Да, Annotation Based Config

Подробнее см. п. 1.24

Разные варианты:

    @Profile("prod")
    @Profile("!prod")
    @Profile({"prod", "dev"})

### 1.27 Сколько профилей можно иметь

Spring явно не ограничивает количество профилей, но внутри использует массив для хранения профилей. Размер массива в Java ограничен Integer.MAX_VALUE (2^31-1), соответственно столько и профилей может быть 

### 1.28 Как внедрить литеральное значение в бины

Через аннотацию **@Value**

Можно применить к:

* полю
* параметру конструктора
* к методу (все параметры метода получат одинаковое значение)
* к параметру метода (будет работать только если на уровне метода нет **@Value** или **@Autowired**)
* к аннотации

Внутри **@Value** можно указать

* простое значение
    - `@Value("John Silver")`, `@Value("true")`
* ссылку на свойство
    - `@Value("${app.database.url}")`
* выражение SpEL
    - `@Value("#('${app.data}'.toUpperCase())")`


### 1.29 Назначение @Value

Установка свойств для

* полей бинов
* параметров методов
* параметров конструкторов

Можно устанавливать

* простые значения (строки, примитивные)
* внедрять свойства, значения переменных окружения
    - для Spring свойства и переменные окружения - одна абстракция `Environment`
    - например `@Value("${JAVA_HOME}")`
    - если свойства - не забыть подключить источник через `@PropertySource`
* внедрять результат **SpEL**
    - начинается с `#`: `@Value("#{500 * 2}")`
* внедрять значения полей других бинов
    - обращение по имени бина и через `#`
    - `@Value("#{someBean.someField}")`
* внедрять значения в коллекции из литералов, свойств, других бинов
    - может понадобится бин типа **ConversionService**

Можно задавать значения по умолчанию
